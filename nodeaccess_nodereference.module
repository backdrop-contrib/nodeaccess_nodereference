<?php
// $Id$


/**
 * Implementation of hook_init().
 */
function nodeaccess_nodereference_init() {
  if ($_GET['q'] != 'batch') {
    if (nodeaccess_nodereference_status('needs_rebuild')) {
      variable_set('nodeaccess_nodereference_messages', drupal_get_messages());
      nodeaccess_nodereference_rebuild(TRUE);
    }
    elseif (variable_get('nodeaccess_nodereference_nodelist', FALSE)) {
      nodeaccess_nodereference_status('doing_rebuild', TRUE);

      // Process the next 20 nodes - we would *normally* only expect a single node here though.
      $limit = variable_get('nodeaccess_nodereference_limit', 20);

      for ($i = 0; $i < $limit; $i++) {
        $list = variable_get('nodeaccess_nodereference_nodelist', array());
        $nid = array_shift($list);
        $loaded_node = node_load($nid, NULL, TRUE);
        // To preserve database integrity, only aquire grants if the node
        // loads successfully.
        if (!empty($loaded_node)) {
          nodeaccess_nodereference_acquire_grants($loaded_node);
        }
        if (empty($list)) {
          variable_del('nodeaccess_nodereference_nodelist');
          break;
        }
        else {
          variable_set('nodeaccess_nodereference_nodelist', $list);
        }
      }

      nodeaccess_nodereference_status('doing_rebuild', FALSE);
    }
  }
}

/**
 * Implementation of hook_perm().
 */
function nodeaccess_nodereference_perm() {
  return array('administer node access node reference');
}

/**
 * Implementation of hook_menu().
 */
function nodeaccess_nodereference_menu() {
  $items = array();

  $items['admin/settings/nodeaccess_nodereference'] = array(
    'title' => 'Node access node reference settings',
    'description' => t('Configure Node Access Node Reference.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodeaccess_nodereference_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
  );
    
  return $items;
}

/**
 * System settings form for nodeaccess_nodereference.
 */
function nodeaccess_nodereference_admin_settings() {
  
  $form['nodeaccess_nodereference_priority'] = array(
    '#type' => 'weight',
    '#title' => t('Set node grants priority for Node Access Node Reference'),
    '#default_value' => variable_get('nodeaccess_nodereference_priority', 0),
    '#description' => t('If you are only using this access control module, you can safely ignore this. 
    If you are using multiple access control modules you can adjust the priority of this module.'),
  );

  $form['nodeaccess_nodereference_limit'] = array(
    '#type' => 'textfield',
    '#maxlength' => '10',
    '#size' => '3',
    '#title' => t('Max nodes to process in a single request'),
    '#default_value' => variable_get('nodeaccess_nodereference_limit', 20),
    '#description' => t('Sites with a lot of users may need to set this lower if problems occur.'),
  );

  return system_settings_form($form);
}

/**
 * Implementation of hook_node_grants().
 */
function nodeaccess_nodereference_node_grants($account, $op) {
  if ($account->uid) {
    $grants['nodeaccess_nodereference'][] = $account->uid;
    return $grants;
  }
  return NULL;
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function nodeaccess_nodereference_form_content_field_edit_form_alter(&$form, $form_state) {
  if ($form['#field']['type'] == 'nodereference') {
    $data = nodeaccess_nodereference_field_settings($form['#field']['type_name'], $form['#field']['field_name']);

    $form['widget']['nodeaccess_nodereference_view'] = array(
      '#type' => 'checkbox',
      '#title' => t('Pass on "view" node access'),
      '#default_value' => $data['view'],
      '#description' => t('View access on this node will be given if the user has access to one of the referenced nodes.'),
      '#weight' => 42,
    );

    $form['widget']['nodeaccess_nodereference_update'] = array(
      '#type' => 'checkbox',
      '#title' => t('Pass on "edit" node access'),
      '#default_value' => $data['update'],
      '#description' => t('Edit access on this node will be given if the user has access to one of the referenced nodes.'),
      '#weight' => 43,
    );

    $form['widget']['nodeaccess_nodereference_delete'] = array(
      '#type' => 'checkbox',
      '#title' => t('Pass on "delete" node access'),
      '#default_value' => $data['delete'],
      '#description' => t('Delete access on this node will be given if the user has access to one of the referenced nodes.'),
      '#weight' => 44,
    );

    $form['#submit'][] = 'nodeaccess_nodereference_content_field_edit_form_submit';
  }
}

/**
 * Extra submit function for User Reference field config.
 */
function nodeaccess_nodereference_content_field_edit_form_submit($form, &$form_state) {
  $form_values = &$form_state['values'];
  $data = array(
    'view' => $form_values['nodeaccess_nodereference_view'],
    'update' => $form_values['nodeaccess_nodereference_update'],
    'delete' => $form_values['nodeaccess_nodereference_delete'],
  );
  nodeaccess_nodereference_field_settings($form_values['type_name'], $form_values['field_name'], $data);
  $nodes = node_load(array('type' => $form_values['type_name']));
  if ($nodes) {
    node_access_needs_rebuild(TRUE);
  }
}

/**
 * Implementation of hook_node_access_records().
 */
function nodeaccess_nodereference_node_access_records($node) {
  // first ensure we only execute this during the custom rebuild, not the drupal rebuild.
  if (nodeaccess_nodereference_status('doing_rebuild')) {
    // create an array of grants
    $grants = array();
    // grab some info about this content type from cck
    $content_types = content_types($node->type);
    // pull out the fields settings
    $fields = &$content_types['fields'];
    // get a list of all user IDs on the site
    $uids = nodeaccess_nodereference_users();
    // set priority according to config
    $priority = variable_get('nodeaccess_nodereference_priority', 0);
    // ensure $fields is an array
    if (is_array($fields)) {
      
      // Go through each user.
      foreach ($uids as $uid) {
        // Ensure they are not anonymous
        if ($uid) {
          // Load the user object
          $user_account = user_load($uid);

          // Deny this user access by default.
          $view = FALSE;
          $update = FALSE;
          $delete = FALSE;

          // Check each field in the node
          foreach ($fields as $field) {
            // Check if it is a nodereference
            if ($field['type'] == 'nodereference') {
              // Get the data about this nodereference field
              $data = nodeaccess_nodereference_field_settings($node->type, $field['field_name']);
              // Check if this nodereference allows any access
              if (($data['view'] || $data['update'] || $data['delete'])) {
                // Foreach referenced node 
                foreach ((array)$node->$field['field_name'] as $nodereference) {
                  // Load the node
                  $reference = node_load($nodereference['nid']);
                  // Check if the node is loaded
                  if ($reference) {
                    // If user does not yet have view access, and this field
                    // gives that kind of access, check if they should get it.
                    if (!$view && $data['view']) {
                      $view = nodeaccess_nodereference_node_access('view', $reference, $user_account);
                    }
                    // If user does not yet have update access, and this field
                    // gives that kind of access, check if they should get it.
                    if (!$update && $data['update']) {
                      $update = nodeaccess_nodereference_node_access('update', $reference, $user_account);
                    }
                    // If user does not yet have delete access, and this field
                    // gives that kind of access, check if they should get it.
                    if (!$delete && $data['delete']) {
                      $delete = nodeaccess_nodereference_node_access('delete', $reference, $user_account);
                    }
                    // If this user has been given all 3 types of access
                    if ($view && $update && $delete) {
                        // nothing more we can do for this user, break out of 2 foreach loops.
                        break 2;
                    }
                  }
                }
              }
            }
          }

          // If this user has been given any access
          if ($view || $update || $delete) {
            // Create a grant for it
            if (!isset($grants[$uid])) {
              $grants[$uid] = array(
                'realm' => 'nodeaccess_nodereference',
                'gid' => $uid,
                'priority' => $priority,
              );
            }
            // and add the right settings to the grants
            if ($view) {
              $grants[$uid]['grant_view'] = 1;
            }
            if ($update) {
              $grants[$uid]['grant_update'] = 1;
            }
            if ($delete) {
              $grants[$uid]['grant_delete'] = 1;
            }
          }

        }
      }
    }
    if (!empty($grants)) {
      return $grants;
    }
  }
  else {
    $list = variable_get('nodeaccess_nodereference_nodelist', array());
    $list[] = $node->nid;
    variable_set('nodeaccess_nodereference_nodelist', $list);
  }
  return NULL;
}

/**
 * Get all users on the site.
 */
function nodeaccess_nodereference_users() {
  $query = 'SELECT uid FROM {users}';
  $result = db_query($query);
  $users = array();
  while ($row = db_fetch_array($result)) {
    $users[] = $row['uid'];
  }
  return $users;
}

/**
 * A version of node_access_needs_rebuild().
 *
 * @param $status_type
 *   'need_rebuild' or 'doing_rebuild'.
 * @param $status
 *   TRUE, FALSE, or NULL
 * @return
 *   The status of the status type.
 */
function nodeaccess_nodereference_status($status_type, $status = NULL) {
  static $data = NULL;
  if ((is_null($data[$status_type]) || !isset($data[$status_type])) && (!isset($status) || is_null($status))) {
    $data[$status_type] = variable_get('nodeaccess_nodereference_'. $status_type, FALSE);
  }
  elseif (is_bool($status)) {
    if ($status) {
      $data[$status_type] = TRUE;
      variable_set('nodeaccess_nodereference_'. $status_type, TRUE);
    }
    else {
      $data[$status_type] = FALSE;
      variable_del('nodeaccess_nodereference_'. $status_type);
    }
  }
  return $data[$status_type];
}

/**
 * A version of node_access().
 */
function nodeaccess_nodereference_node_access($op, $node, $account = NULL) {
  global $user;

  if (!$node || !in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    // If there was no node to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // Convert the node to an object if necessary:
  if ($op != 'create') {
    $node = (object)$node;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }
  // If the node is in a restricted format, disallow editing.
  if ($op == 'update' && !filter_access($node->format)) {
    return FALSE;
  }

  if (user_access('administer nodes', $account)) {
    return TRUE;
  }

  if (!user_access('access content', $account)) {
    return FALSE;
  }

  // Can't use node_invoke(), because the access hook takes the $op parameter
  // before the $node parameter.
  $module = node_get_types('module', $node);
  if ($module == 'node') {
    $module = 'node_content'; // Avoid function name collisions.
  }
  $access = module_invoke($module, 'access', $op, $node, $account);
  if (!is_null($access)) {
    return $access;
  }

  // If the module did not override the access rights, use those set in the
  // node_access table.
  if ($op != 'create' && $node->nid && $node->status) {
    $grants = array();
    foreach (node_access_grants($op, $account) as $realm => $gids) {
      foreach ($gids as $gid) {
        $grants[] = "(gid = $gid AND realm = '$realm')";
      }
    }

    $grants_sql = '';
    if (count($grants)) {
      $grants_sql = 'AND ('. implode(' OR ', $grants) .')';
    }

    $sql = "SELECT COUNT(*) FROM {nodeaccess_nodereference} WHERE (nid = 0 OR nid = %d) $grants_sql AND grant_$op >= 1";
    $result = db_query($sql, $node->nid);
    return (db_result($result));
  }

  // Let authors view their own nodes.
  if ($op == 'view' && $account->uid == $node->uid && $account->uid != 0) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Copy node_access table to nodeaccess_nodereference table.
 */
function nodeaccess_nodereference_table() {
  db_query('DELETE FROM {nodeaccess_nodereference}');
  db_query('INSERT INTO {nodeaccess_nodereference} SELECT * FROM {node_access}');
}

/**
 * A version of node_access_rebuild().
 */
function nodeaccess_nodereference_rebuild($batch_mode = FALSE) {
  nodeaccess_nodereference_status('needs_rebuild', FALSE);
  nodeaccess_nodereference_status('doing_rebuild', TRUE);

  if ($batch_mode) {

    // If not in 'safe mode', increase the maximum execution time.
    if (!ini_get('safe_mode')) {
      set_time_limit(240);
    }
    $result = db_query(nodeaccess_nodereference_fetch_nodes_sql());
    $list = array();
    while ($node = db_fetch_object($result)) {
      $list[] = $node->nid;
    }
    variable_set('nodeaccess_nodereference_nodelist', $list);

    $batch = array(
      'title' => t('Rebuilding node reference access permissions'),
      'operations' => array(
        array('_nodeaccess_nodereference_rebuild_batch_operation', array()),
      ),
      'finished' => '_nodeaccess_nodereference_rebuild_batch_finished'
    );
    batch_set($batch);
    batch_process('admin/content/node-settings');
  }
  else {
    // If not in 'safe mode', increase the maximum execution time.
    if (!ini_get('safe_mode')) {
      set_time_limit(240);
    }
    $result = db_query(nodeaccess_nodereference_fetch_nodes_sql());
    while ($node = db_fetch_object($result)) {
      $loaded_node = node_load($node->nid, NULL, TRUE);
      // To preserve database integrity, only aquire grants if the node
      // loads successfully.
      if (!empty($loaded_node)) {
        nodeaccess_nodereference_acquire_grants($loaded_node);
      }
    }

  }

  if (!isset($batch)) {
    nodeaccess_nodereference_status('doing_rebuild', FALSE);
    drupal_set_message(t('Node reference access permissions have been rebuilt.'));
    cache_clear_all();
  }

}

/**
 * A version of _node_access_rebuild_batch_operation().
 */
function _nodeaccess_nodereference_rebuild_batch_operation(&$context) {
  if (empty($context['sandbox'])) {
    // Initiate multistep processing.
    $context['sandbox']['progress'] = 0;
    //$context['sandbox']['current_node'] = 0;
    $list = variable_get('nodeaccess_nodereference_nodelist', array());
    $context['sandbox']['max'] = count($list);
  }

  // Process the next 20 nodes.
  $limit = variable_get('nodeaccess_nodereference_limit', 20);

  for ($i = 0; $i < $limit; $i++) {
    $list = variable_get('nodeaccess_nodereference_nodelist', array());
    $nid = array_shift($list);
    $loaded_node = node_load($nid, NULL, TRUE);
    // To preserve database integrity, only aquire grants if the node
    // loads successfully.
    if (!empty($loaded_node)) {
      nodeaccess_nodereference_acquire_grants($loaded_node);
    }
    $context['sandbox']['progress']++;
    //$context['sandbox']['current_node'] = $loaded_node->nid;
    if (empty($list)) {
      variable_del('nodeaccess_nodereference_nodelist');
      break;
    }
    else {
      variable_set('nodeaccess_nodereference_nodelist', $list);
    }
  }

  // Multistep processing : report progress.
  if ($context['sandbox']['progress'] != $context['sandbox']['max'] && $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
  elseif (!$context['sandbox']['max']) {
    $context['finished'] = 1;
  }
}

/**
 * A version of _node_access_rebuild_batch_finished().
 */
function _nodeaccess_nodereference_rebuild_batch_finished($success, $results, $operations) {
  nodeaccess_nodereference_status('doing_rebuild', FALSE);
  $messages = variable_get('nodeaccess_nodereference_messages', NULL);
  variable_del('nodeaccess_nodereference_messages');
  foreach ($messages as $type => $msgs) {
    foreach($msgs as $msg) {
      drupal_set_message($msg, $type);
    }
  }
  if ($success) {
    drupal_set_message(t('The node reference access permissions have been rebuilt.'));
  }
  else {
    drupal_set_message(t('The node reference access permissions have not been properly rebuilt.'), 'error');
  }
  cache_clear_all();
}

/**
 * A version of node_access_acquire_grants().
 */
function nodeaccess_nodereference_acquire_grants($node) {
  $grants = module_invoke('nodeaccess_nodereference', 'node_access_records', $node);

  if (!empty($grants)) {
    // retain grants by highest priority
    $grant_by_priority = array();
    foreach ($grants as $g) {
      $grant_by_priority[intval($g['priority'])][] = $g;
    }
    krsort($grant_by_priority);
    $grants = array_shift($grant_by_priority);

    node_access_write_grants($node, $grants, NULL, FALSE);
  }

}

/**
 * Build SQL to fetch nodes that have nodereferences.
 */
function nodeaccess_nodereference_fetch_nodes_sql() {
  $sql = 'SELECT n.nid FROM {node} n ';
  $fields = content_fields();
  $joins = array();
  $wheres = array();
  foreach ((array)$fields as $field) {
    if ($field['type'] == 'nodereference') {
      if ($field['db_storage']) {
        $joins[] = 'INNER JOIN {content_type_'. $field['type_name'] .'} '. 
          $field['type_name'] .' ON n.vid = '. $field['type_name'] .'.vid';
        $where_field = $field['type_name'] .'.'. $field['field_name'] .'_nid';
      }
      else {
        $joins[] = 'INNER JOIN {content_'. $field['field_name'] .'} '. 
          $field['field_name'] .' ON n.vid = '. $field['field_name'] .'.vid';
        $where_field = $field['field_name'] .'.'. $field['field_name'] .'_nid';
      }
      $wheres[] = $where_field ." IS NOT NULL";
    }
  }
  $sql .= count($joins) ? implode(' ', $joins) : '';
  $sql .= ' WHERE ';
  $sql .= count($wheres) ? implode(' OR ', $wheres) : 'FALSE';
  return $sql;
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function nodeaccess_nodereference_form_node_configure_rebuild_confirm_alter(&$form, $form_state) {
  array_unshift($form['#submit'], 'nodeaccess_nodereference_rebuild_submit');
}

/**
 * Copy the table when someone presses that rebuild button.
 */
function nodeaccess_nodereference_rebuild_submit($form, &$form_state) {
  nodeaccess_nodereference_table();
  nodeaccess_nodereference_status('needs_rebuild', TRUE);
}

/**
 * Implementation of hook_nodeapi().
 */
function nodeaccess_nodereference_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'insert':
    case 'update':
      // grab some info about this content type from cck
      $content_types = content_types($node->type);
      // pull out the fields settings
      $fields = &$content_types['fields'];
      // ensure $fields is an array
      if (is_array($fields)) {
        // Check each field in the node
        foreach ($fields as $field) {
          // Check if it is a nodereference
          if ($field['type'] == 'nodereference') {
            // Get the data about this nodereference field
            $data = nodeaccess_nodereference_field_settings($node->type, $field['field_name']);
            // Check if this nodereference allows any access
            if (($data['view'] || $data['update'] || $data['delete'])) {
              nodeaccess_nodereference_table();
              return;
            }
          }
        }
      }
      break;
  }
}

/**
 * Set and get nodeaccess nodereference field settings.
 *
 * @param $type_name
 *   The node type.
 * @param $field_name
 *   The name of the field.
 * @param $variable
 *   If set will update the value of the settings for this field.
 * @return
 *   The stored or updated value of the settings for this field.
 */
function nodeaccess_nodereference_field_settings($type_name, $field_name, $variable = NULL) {

  // 'get' the variable
  $data = variable_get('nodeaccess_nodereference', NULL);
  if (!$data || !isset($data[$type_name][$field_name])) {
    // Attempt to get result from old variables.
    $old_varname = substr('nodeaccess_nodereference_'. $field_name .'_'. $type_name, 0, 48);
    $old_data = variable_get($old_varname, NULL);
    if (is_array($old_data)) {
      variable_del($old_varname);
      nodeaccess_nodereference_field_settings($type_name, $field_name, $old_data);
      $data[$type_name][$field_name] = $old_data;
    }
    else {
      // default
      $data[$type_name][$field_name] = array(
        'view' => 0, 
        'update' => 0, 
        'delete' => 0,
      );
    }
  }

  // change and 'set' the variable
  if (isset($variable)) {
    $data[$type_name][$field_name] = $variable;
    variable_set('nodeaccess_nodereference', $data);
  }

  return $data[$type_name][$field_name];
}
